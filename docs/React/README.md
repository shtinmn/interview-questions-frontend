# Блок вопросов и ответов на тему **React**

## React core

### Что такое React?

React — это библиотека JavaScript с открытым исходным кодом, которая используется для создания пользовательских
интерфейсов, особенно для одностраничных приложений.

### Каковы основные особенности React?

- Он использует VirtualDOM вместо RealDOM, учитывая, что манипуляции с RealDOM обходятся дорого.
- Поддерживает рендеринг на стороне сервера.
- Следует однонаправленному потоку данных или привязке данных.
- Использует повторно используемые/компонуемые компоненты пользовательского интерфейса для разработки представления.

### Что такое JSX?

*JSX* — это XML-подобное расширение синтаксиса для ECMAScript (аббревиатура расшифровывается как *JavaScript XML*). По
сути, он просто обеспечивает синтаксический сахар для функции `React.createElement()`, давая нам выразительность
JavaScript наряду с синтаксисом шаблона HTML.

In the example below text inside `<h1>` tag is returned as JavaScript function to the render function.

 ```jsx harmony
class App extends React.Component {
	render() {
		return (
			<div>
				<h1>{'Welcome to React world!'}</h1>
			</div>
		)
	}
}
   ```

### В чем разница между элементом и компонентом?

*Элемент* — это простой объект, описывающий то, что вы хотите отобразить на экране с точки зрения узлов DOM или других
компонентов. *Элементы* могут содержать другие *Элементы* в своих свойствах. Создание элемента React дешево. После того,
как элемент создан, он никогда не мутирует.

Объектное представление React Element будет следующим:

 ```javascript
const element = React.createElement(
	'div',
	{id: 'login-btn'},
	'Login'
)
```

Приведенная выше функция `React.createElement()` возвращает объект:

```JSON
{
  "type": "div",
  "props": {
	"children": "Login",
	"id": "login-btn"
  }
}
```

И, наконец, он рендерится в DOM с помощью `ReactDOM.render()`:

```html

<div id='login-btn'>Login</div>
```

Принимая во внимание, что **компонент** может быть объявлен несколькими различными способами. Это может быть класс с
методом `render()` или он может быть определен как функция. В любом случае он принимает props в качестве входных данных
и возвращает дерево JSX в качестве вывода:

```jsx harmony
const Button = ({onLogin}) =>
	<div id={'login-btn'} onClick={onLogin}>Login</div>
```

Затем JSX транспилируется в дерево функций React.createElement():

 ```javascript
const Button = ({onLogin}) => React.createElement(
	'div',
	{id: 'login-btn', onClick: onLogin},
	'Login'
)
```

### Как создавать компоненты в React?

Существует два возможных способа создания компонента.

1. **Функциональные компоненты:** Это самый простой способ создания компонента. Это чистые функции JavaScript, которые
   принимают объект props в качестве первого параметра и возвращают элементы React:

```jsx harmony
function Greeting({message}) {
	return <h1>{`Hello, ${message}`}</h1>
}
```

2. **Компоненты класса:** Вы также можете использовать класс ES6 для определения компонента. Вышеупомянутый
   функциональный компонент может быть записан как:

```jsx harmony
class Greeting extends React.Component {
	render() {
		return <h1>{`Hello, ${this.props.message}`}</h1>
	}
}
 ```

### Что такое state?

Состояние(State) компонента — это объект, который содержит некоторую информацию, которая может измениться в течение
срока службы компонента. Мы всегда должны стараться сделать наше состояние максимально простым и свести к минимуму
количество компонентов с состоянием.

Давайте создадим компонент с состоянием:

```jsx harmony
class User extends React.Component {
	constructor(props) {
		super(props)
		this.state = {
			message: 'Welcome to React world'
		}
	}

	render() {
		return (
			<div>
				<h1>{this.state.message}</h1>
			</div>
		)
	}
}
 ```

Состояние похоже на props, но оно является внутренним и полностью контролируется компонентом. т.е. он недоступен для
любого другого компонента, пока компонент-владелец не решит передать его.

### Что такое props?

*Props* являются входными данными для компонентов. Это отдельные значения или объекты, содержащие набор значений,
которые передаются компонентам при создании с использованием соглашения об именах, аналогичного атрибутам HTML-тегов.
Это данные, передаваемые от родительского компонента к дочернему компоненту.

Основная цель props в React — обеспечить следующие функциональные возможности компонента:

1. Передавать данные в компонент.
2. Побуждать к изменению state.
3. Использовать через `this.props.reactProp` внутри метода `render()` компонента.

Например, давайте создадим элемент со свойством `reactProp`:

 ```jsx harmony
<Element reactProp={'1'}/>
```

`reactProp` затем становится свойством, прикрепленным к собственному объекту props React, который изначально уже
существует во всех компонентах, созданных с использованием библиотеки React.

```
props.reactProp
```

### В чем разница между state и props?

И *props*, и *state* являются простыми объектами JavaScript. Хотя оба они содержат информацию, влияющую на результат
рендеринга, они различаются по своей функциональности по отношению к компонентам. Props передаются компоненту аналогично
параметрам функции, тогда как состояние управляется внутри компонента аналогично переменным, объявленным внутри функции.

### Почему нельзя обновлять состояние напрямую?

Если обновить состояние напрямую, компонент не будет повторно рендерится.

```javascript
//Wrong
this.state.message = 'Hello world'
```

Вместо этого используйте метод `setState()`. Он планирует обновление объекта состояния компонента. Когда состояние
изменяется, компонент отвечает повторным рендерингом.

 ```javascript
 //Correct
this.setState({message: 'Hello World'})
 ```

**Примечание.** Вы можете напрямую присваивать объекту состояния либо в *конструкторе*, либо используя последний
синтаксис объявления поля класса javascript.

### Какова цель функции обратного вызова в качестве аргумента `setState()`?

Функция обратного вызова вызывается, когда setState завершается и компонент визуализируется. Поскольку `setState()`
является **асинхронным**, функция обратного вызова используется для любого действия.

**Примечание.** Рекомендуется использовать метод жизненного цикла, а не эту функцию обратного вызова.

```javascript
setState({name: 'John'}, () => console.log('The name has updated and component re-rendered'))
```

### В чем разница между обработкой событий HTML и React?

Ниже приведены некоторые из основных различий между обработкой событий HTML и React,

1. В HTML имя события обычно представляется в *lowercase*:

```jsx
<button onclick='activate()'/>
```

В то время как в React следует соглашению *camelCase*:

```jsx harmony
<button onClick={activate}/>
```

2. В HTML вы можете вернуть `false`, чтобы предотвратить поведение по умолчанию:

```html
<a href='#' onclick='console.log("The link was clicked."); return false;'/>
```

В то время как в React вы должны вызывать `preventDefault()` явно:

```javascript
function handleClick(event) {
	event.preventDefault()
	console.log('The link was clicked.')
}
```

3. В HTML вам нужно вызвать функцию, добавив `()`
   В то время как в реакции вы не должны добавлять `()` к имени функции. (см. функцию «activate» в первом примере)

### Что такое чистые(pure) компоненты?

*`React.PureComponent`* точно такой же, как *`React.Component`*, за исключением того, что он обрабатывает для вас
метод `shouldComponentUpdate()`. При изменении props или state *PureComponent* выполнит поверхностное сравнение как
props и state. *Компонент*, с другой стороны, не будет сравнивать текущие props и state перед перерисовкой. Таким
образом, компонент будет перерисовываться по умолчанию всякий раз, когда вызывается `shouldComponentUpdate`.


